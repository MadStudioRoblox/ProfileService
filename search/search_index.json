{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>ProfileService is a stand-alone ModuleScript that specialises in loading and auto-saving DataStore profiles.</p> <p>A DataStore <code>Profile</code> (Later referred to as just <code>Profile</code>) is a set of data which is meant to be loaded up only once inside a Roblox server and then written to and read from locally on that server (With no delays associated with talking with the DataStore every time data changes) whilst being periodically auto-saved and saved immediately once after the server finishes working with the <code>Profile</code>.</p> <p>The benefits of using ProfileService for your game's profiles are:</p> <ul> <li>Easy to learn, and eventually forget - ProfileService does not give you any data getter or setter functions. It gives you the freedom to write your own data interface.</li> <li>Built for massive scalability - low resource footprint, no excessive type checking. Great for 100+ player servers. ProfileService automatically spreads the DataStore API calls evenly within the auto-save loop timeframe.</li> <li>Already does the things you wouldn't dare script yourself (but should) - session-locking is essential to keeping your data protected from multiple server editing - this is a potential cause of item loss or item duplication loopholes. ProfileService offers a very comprehensive and short API for handling session-locking yourself or just letting ProfileService do it automatically for you.</li> <li>Future-proof - with features like <code>MetaTags</code> and <code>GlobalUpdates</code>, you will always be able to add new functionality to your profiles without headaches.</li> <li>Made for ambitious projects - ProfileService is a profile object abstraction detached from the <code>Player</code> instance - this allows the developer to create profiles for entities other than players, such as: group-owned houses, savable multiplayer game instances, etc.</li> </ul> <p>If anything is missing or broken, file an issue on GitHub.</p> <p>If you need help integrating ProfileService into your project, join the discussion.</p> <p>Disclaimer: Although ProfileService has been thoroughly tested (Auto testing source included - ProfileTest.lua), it has not been used within a large scale Roblox project yet. ProfileService is the successor to an earlier DataStore implementation used in The Mad Murderer 2</p>"},{"location":"#why-not-datastore2","title":"Why not DataStore2?","text":"<p>DataStore2 is mostly a Roblox DataStore wrapper module which automatically saves duplicates of your data. ProfileService is an extension module which gives you powerful tools to manage profile session-locking, cross server gifting and profile data organizing.</p> <p>ProfileService protects your data only from the relevant Roblox server problems. It's completely stacked when it comes to protecting your game data from item duplication exploits.</p> <p>ProfileService is striving to be a DataStore solution that is the most accurate implementation of data storage following the development guidelines and practices provided in the official Roblox API.</p>"},{"location":"api/","title":"API","text":"<p>Warning</p> <p>Never yield (use <code>wait()</code> or asynchronous Roblox API calls) inside listener functions</p> <p>Notice</p> <p>Methods with <code>Async</code> in their name are methods that will yield - just like <code>wait()</code></p>"},{"location":"api/#profileservice","title":"ProfileService","text":""},{"location":"api/#profileserviceservicelocked","title":"ProfileService.ServiceLocked","text":"<p><pre><code>ProfileService.ServiceLocked   [bool]\n</code></pre> Set to false when the Roblox server is shutting down. <code>ProfileStore</code> methods should not be called after this value is set to <code>false</code></p>"},{"location":"api/#profileserviceissuesignal","title":"ProfileService.IssueSignal","text":"<p><pre><code>ProfileService.IssueSignal   [ScriptSignal](error_message [string], profile_store_name [string], profile_key [string])\n</code></pre> Analytics endpoint for DataStore error logging. Example usage: <pre><code>ProfileService.IssueSignal:Connect(function(error_message, profile_store_name, profile_key)\n  pcall(function()\n    AnalyticsService:FireEvent(\n      \"ProfileServiceIssue\",\n      error_message,\n      profile_store_name,\n      profile_key\n    )\n  end)\nend)\n</code></pre></p>"},{"location":"api/#profileservicecorruptionsignal","title":"ProfileService.CorruptionSignal","text":"<p><pre><code>ProfileService.CorruptionSignal   [ScriptSignal](profile_store_name [string], profile_key [string])\n</code></pre> Analytics endpoint for cases when a DataStore key returns a value that has all or some of it's profile components set to invalid data types. E.g., accidentally setting Profile.Data to a non table value</p>"},{"location":"api/#profileservicecriticalstatesignal","title":"ProfileService.CriticalStateSignal","text":"<p><pre><code>ProfileService.CriticalStateSignal   [ScriptSignal] (is_critical_state [bool])\n</code></pre> Analytics endpoint for cases when DataStore is throwing too many errors and it's most likely affecting your game really really bad - this could be due to developer errors or due to Roblox server problems. Could be used to alert players about data store outages.</p>"},{"location":"api/#profileservicegetprofilestore","title":"ProfileService.GetProfileStore()","text":"<p><pre><code>ProfileService.GetProfileStore(\n    profile_store_index,\n    profile_template\n) --&gt; [ProfileStore]\n-- profile_store_index   [string] -- DataStore name\n-- OR\n-- profile_store_index   [table]: -- Allows the developer to define more GlobalDataStore variables\n--  {\n--    Name = \"StoreName\", -- [string] -- DataStore name\n--    -- Optional arguments:\n--    Scope = \"StoreScope\", -- [string] -- DataStore scope\n--  }\n-- profile_template     [table] -- Profile.Data will default to\n--   given table (deep-copy) when no data was saved previously\n</code></pre> <code>ProfileStore</code> objects expose methods for loading / viewing profiles and sending global updates. Equivalent of :GetDataStore() in Roblox DataStoreService API.</p> <p>Notice</p> <p>By default, <code>profile_template</code> is only copied for <code>Profile.Data</code> for new profiles. Changes made to <code>profile_template</code> can be applied to <code>Profile.Data</code> of previously saved profiles by calling Profile:Reconcile(). You can also create your own function to fill in the missing components in <code>Profile.Data</code> as soon as it is loaded or have <code>nil</code> exceptions in your personal <code>:Get()</code> and <code>:Set()</code> method libraries.</p>"},{"location":"api/#profilestore","title":"ProfileStore","text":""},{"location":"api/#profilestoreloadprofileasync","title":"ProfileStore:LoadProfileAsync()","text":"<p><pre><code>ProfileStore:LoadProfileAsync(\n  profile_key,\n  not_released_handler\n) --&gt; [Profile] or nil\n-- profile_key            [string] -- DataStore key\n-- not_released_handler   nil or []: -- Defaults to \"ForceLoad\"\n--      [string] \"ForceLoad\" -- Force loads profile on first call\n--      OR\n--      [string] \"Steal\" -- Steals the profile ignoring it's session lock\n--      OR\n--      [function] (place_id, game_job_id) --&gt; [string] \"Repeat\", \"Cancel\", \"ForceLoad\" or \"Steal\"\n--          place_id      [number] or nil\n--          game_job_id   [string] or nil\n</code></pre> For basic usage, pass <code>nil</code> for the <code>not_released_handler</code> argument.</p> <p><code>not_released_handler</code> as a <code>function</code> argument is called when the profile is session-locked by a remote Roblox server: <pre><code>local profile = ProfileStore:LoadProfileAsync(\n  \"Player_2312310\",\n  function(place_id, game_job_id)\n    -- place_id and game_job_id identify the Roblox server that has\n    --   this profile currently locked. In rare cases, if the server\n    --   crashes, the profile will stay locked until ForceLoaded by\n    --   a new session.\n    return \"Repeat\" or \"Cancel\" or \"ForceLoad\" or \"Steal\"\n  end\n)\n</code></pre> <code>not_released_handler</code> must return one of the following values:</p> <ul> <li><code>return \"Repeat\"</code> - ProfileService will repeat the profile loading proccess and may call the release handler again</li> <li><code>return \"Cancel\"</code> - <code>:LoadProfileAsync()</code> will immediately return nil</li> <li><code>return \"ForceLoad\"</code> - ProfileService will indefinitely attempt to load the profile. If the profile is session-locked by a remote Roblox server, it will either be released for that remote server or \"stolen\" (Stealing is necessary for remote servers that are not responding in time and for handling crashed server session-locks).</li> <li><code>return \"Steal\"</code> - The profile will usually be loaded immediately, ignoring an existing remote session lock and applying a session lock for this session. <code>\"Steal\"</code> can be used to clear dead session locks faster than <code>\"ForceLoad\"</code> assuming your code knows that the session lock is dead.</li> </ul> <p>Notice</p> <p>ProfileService saves profiles to live DataStore keys in Roblox Studio when Roblox API services are enabled. See ProfileStore.Mock if saving to live keys during testing is not desired.</p> <p>Warning</p> <p><code>:LoadProfileAsync()</code> can return <code>nil</code> when another remote Roblox server attempts to load the profile at the same time. This case should be extremely rare and it would be recommended to :Kick() the player if <code>:LoadProfileAsync()</code> does not return a <code>Profile</code> object.</p> <p>Do not load a profile of the same key again before it is released</p> <p>Trying to load a profile that has already been session-locked on the same server will result in an error. You may, however, instantly load the profile again after releasing it with <code>Profile:Release()</code>.</p>"},{"location":"api/#profilestoreglobalupdateprofileasync","title":"ProfileStore:GlobalUpdateProfileAsync()","text":"<pre><code>ProfileStore:GlobalUpdateProfileAsync(\n  profile_key,\n  update_handler\n) --&gt; [GlobalUpdates] or nil\n-- profile_key      [string] -- DataStore key\n-- update_handler   [function](global_updates) -- This function is\n--   called with a GlobalUpdates object\n</code></pre> <p>Used to create and manage <code>Active</code> global updates for a specified <code>Profile</code>. Can be called on any Roblox server of your game. Updates should reach the recipient in less than 30 seconds, regardless of whether it was called on the same server the <code>Profile</code> is session-locked to. See Global Updates for more information.</p> <p>Example usage of <code>:GlobalUpdateProfileAsync()</code>: <pre><code>ProfileStore:GlobalUpdateProfileAsync(\n  \"Player_2312310\",\n  function(global_updates)\n    global_updates:AddActiveUpdate({\n      Type = \"AdminGift\",\n      Item = \"Coins\",\n      Amount = 1000,\n    })\n  end\n)\n</code></pre></p> <p>Notice</p> <p><code>:GlobalUpdateProfileAsync()</code> will work for profiles that haven't been created (profiles are created when they're loaded using <code>:LoadProfileAsync()</code> for the first time)</p> <p>Yielding inside the <code>update_handler</code> function will throw an error</p> <p>Avoid rapid use of ProfileStore:GlobalUpdateProfileAsync()</p> <p>Excessive use of ProfileStore:GlobalUpdateProfileAsync() can lead to dead session locks and event lost <code>Profile.Data</code> (latter is mostly possible only if the <code>Profile</code> is loaded in the same session as <code>:GlobalUpdateProfileAsync()</code> is called). This is due to a queue system that executes every write request for the <code>Profile</code> every 7 seconds - if this queue grows larger than the BindToClose timeout (approx. 30 seconds), some requests in the queue can be lost after the game shuts down.</p>"},{"location":"api/#profilestoreviewprofileasync","title":"ProfileStore:ViewProfileAsync()","text":"<pre><code>ProfileStore:ViewProfileAsync(profile_key, version) --&gt; [Profile] or nil\n-- profile_key   [string] -- DataStore key\n-- version       nil or [string] -- DataStore key version\n</code></pre> <p>Passing <code>version</code> argument in mock mode (Or offline mode) will throw an error - Mock versioning is not supported</p> <p>Attempts to load the latest profile version (or a specified version via the <code>version</code> argument) from the DataStore without claiming a session lock. Returns <code>nil</code> if such version does not exist. Returned <code>Profile</code> will not auto-save and releasing won't do anything. Data in the returned <code>Profile</code> can be changed to create a payload which can be saved via Profile:OverwriteAsync().</p> <p><code>:ViewProfileAsync()</code> is the the prefered way of viewing player data without editing it.</p>"},{"location":"api/#profilestoreprofileversionquery","title":"ProfileStore:ProfileVersionQuery()","text":"<p><pre><code>ProfileStore:ProfileVersionQuery(profile_key, sort_direction, min_date, max_date) --&gt; [ProfileVersionQuery]\n-- profile_key      [string]\n-- sort_direction   nil or [Enum.SortDirection] -- Defaults to \"Ascending\"\n-- min_date         nil or [DateTime] or [number] (epoch time millis)\n-- max_date         nil or [DateTime] or [number] (epoch time millis)\n</code></pre> Creates a profile version query using DataStore:ListVersionsAsync() (Official documentation). Results are retrieved through <code>ProfileVersionQuery:Next()</code>. For additional help, check the versioning example in official Roblox documentation. Date definitions are easier with the DateTime (Official documentation) library. User defined day and time will have to be converted to Unix time (Wikipedia) while taking their timezone into account to expect the most precise results, though you can be rough and just set the date and time in the UTC timezone and expect a maximum margin of error of 24 hours for your query results.</p> <p>Examples of query arguments:</p> <ul> <li>Pass <code>nil</code> for <code>sort_direction</code>, <code>min_date</code> and <code>max_date</code> to find the oldest available version</li> <li>Pass <code>Enum.SortDirection.Descending</code> for <code>sort_direction</code>, <code>nil</code> for <code>min_date</code> and <code>max_date</code> to find the most recent version.</li> <li>Pass <code>Enum.SortDirection.Descending</code> for <code>sort_direction</code>, <code>nil</code> for <code>min_date</code> and <code>DateTime</code> defining a time before an event     (e.g. two days earlier before your game unrightfully stole 1,000,000 rubies from a player) for <code>max_date</code> to find the most recent     version of a <code>Profile</code> that existed before said event.</li> </ul> <p>Case example: \"I lost all of my rubies on August 14th!\"</p> <pre><code>-- Get a ProfileStore object with the same arguments you passed to the\n--  ProfileStore that loads player Profiles. It can also just be\n--  the very same ProfileStore object:\n\nlocal ProfileStore = ProfileService.GetProfileStore(store_name, template)\n\n-- If you can't figure out the exact time and timezone the player lost rubies\n--  in on the day of August 14th, then your best bet is to try querying\n--  UTC August 13th. If the first entry still doesn't have the rubies - \n--  try a new query of UTC August 12th and etc.\n\nlocal max_date = DateTime.fromUniversalTime(2021, 08, 13) -- UTC August 13th, 2021\n\nlocal query = ProfileStore:ProfileVersionQuery(\n  \"Player_2312310\", -- The same profile key that gets passed to :LoadProfileAsync()\n  Enum.SortDirection.Descending,\n  nil,\n  max_date\n)\n\n-- Get the first result in the query:\nlocal profile = query:NextAsync()\n\nif profile ~= nil then\n\n  profile:ClearGlobalUpdates()\n\n  profile:OverwriteAsync() -- This method does the actual rolling back;\n    -- Don't call this method until you're sure about setting the latest\n    -- version to a copy of the previous one\n\n  print(\"Rollback success!\")\n\n  print(profile.Data) -- You'll be able to surf table contents if\n    -- you're runing this code in studio with access to API services\n    -- enabled and have expressive output enabled; If the printed\n    -- data doesn't have the rubies, you'll want to change your\n    -- query parameters.\n\nelse\n  print(\"No version to rollback to\")\nend\n</code></pre> <p>Case example: Studying data mutation over time</p> <pre><code>-- You have ProfileService working in your game. You join\n--  the game with your own account and go to https://www.unixtimestamp.com\n--  and save the current UNIX timestamp resembling present time.\n--  You can then make the game alter your data by giving you\n--  currency, items, experience, etc.\n\nlocal ProfileStore = ProfileService.GetProfileStore(store_name, template)\n\n-- UNIX timestamp you saved:\nlocal min_date = DateTime.fromUnixTimestamp(1628952101)\nlocal print_minutes = 5 -- Print the next 5 minutes of history\n\nlocal query = ProfileStore:ProfileVersionQuery(\n  \"Player_2312310\",\n  Enum.SortDirection.Ascending,\n  min_date\n)\n\n-- You can now attempt to print out every snapshot of your data saved\n--  at an average periodic interval of 30 seconds (ProfileService auto-save)\n--  starting from the time you took the UNIX timestamp!\n\nlocal finish_update_time = min_date.UnixTimestampMillis + (print_minutes * 60000)\n\nprint(\"Fetching \", print_minutes, \"minutes of saves:\")\n\nlocal entry_count = 0\n\nwhile true do\n\n  entry_count +=1\n  local profile = query:NextAsync()\n\n  if profile ~= nil then\n\n    if profile.KeyInfo.UpdatedTime &gt; finish_update_time then\n      if entry_count == 1 then\n        print(\"No entries found in set time period. (Start timestamp too early)\")\n      else\n        print(\"Time period finished.\")\n      end\n      break\n    end\n\n    print(\n      \"Entry\", entry_count, \"-\",\n      DateTime.fromUnixTimestampMillis(profile.KeyInfo.UpdatedTime):ToIsoDate()\n    )\n\n    print(profile.Data) -- Printing table for studio expressive output\n\n  else\n    if entry_count == 1 then\n      print(\"No entries found in set time period. (Start timestamp too late)\")\n    else\n      print(\"No more entries in query.\")\n    end\n    break\n  end\n\nend\n</code></pre>"},{"location":"api/#profilestorewipeprofileasync","title":"ProfileStore:WipeProfileAsync()","text":"<p><pre><code>ProfileStore:WipeProfileAsync(profile_key) --&gt; is_wipe_successful [bool]\n-- profile_key   [string] -- DataStore key\n</code></pre> Use <code>:WipeProfileAsync()</code> to erase user data when complying with right of erasure requests. In live Roblox servers <code>:WipeProfileAsync()</code> must be used on profiles created through <code>ProfileStore.Mock</code> after <code>Profile:Release()</code> and it's known that the <code>Profile</code> will no longer be loaded again.</p>"},{"location":"api/#profilestoremock","title":"ProfileStore.Mock","text":"<pre><code>local ProfileTemplate = {}\nlocal GameProfileStore = ProfileService.GetProfileStore(\n  \"PlayerData\",\n  ProfileTemplate\n)\n\nlocal LiveProfile = GameProfileStore:LoadProfileAsync(\n  \"profile_key\",\n  \"ForceLoad\"\n)\nlocal MockProfile = GameProfileStore.Mock:LoadProfileAsync(\n  \"profile_key\",\n  \"ForceLoad\"\n)\nprint(LiveProfile ~= MockProfile) --&gt; true\n\n-- When done using mock profile on live servers: (Prevent memory leak)\nMockProfile:Release()\nGameProfileStore.Mock:WipeProfileAsync(\"profile_key\")\n-- You don't really have to wipe mock profiles in studio testing\n</code></pre> <p><code>ProfileStore.Mock</code> is a reflection of methods available in the <code>ProfileStore</code> object with the exception of profile operations being performed on profiles stored on a separate, detached \"fake\" DataStore that will be forgotten when the game session ends. You may load profiles of the same key from <code>ProfileStore</code> and <code>ProfileStore.Mock</code> in parallel - these will be two different profiles because the regular and mock versions of the same <code>ProfileStore</code> are completely isolated from each other.</p> <p><code>ProfileStore.Mock</code> is useful for customizing your testing environment in cases when you want to enable Roblox API services in studio, but don't want ProfileService to save to live keys: <pre><code>local RunService = game:GetService(\"RunService\")\nlocal GameProfileStore = ProfileService.GetProfileStore(\"PlayerData\", ProfileTemplate)\nif RunService:IsStudio() == true then\n  GameProfileStore = GameProfileStore.Mock\nend\n</code></pre> A few more things:</p> <ul> <li>Even when Roblox API services are disabled, <code>ProfileStore</code> and <code>ProfileStore.Mock</code> will store profiles in separate stores.</li> <li>It's better to think of <code>ProfileStore</code> and <code>ProfileStore.Mock</code> as two different <code>ProfileStore</code> objects unrelated to each other in any way.</li> <li>It's possible to create a project that utilizes both live and mock profiles on live servers!</li> </ul>"},{"location":"api/#profile","title":"Profile","text":""},{"location":"api/#profiledata","title":"Profile.Data","text":"<p><pre><code>Profile.Data   [table]\n-- Non-strict reference - developer can set this value to a new table reference\n</code></pre> <code>Profile.Data</code> is the primary variable of a Profile object. The developer is free to read and write from the table while it is automatically saved to the DataStore. <code>Profile.Data</code> will no longer be saved after being released remotely or locally via <code>Profile:Release()</code>.</p>"},{"location":"api/#profilemetadata","title":"Profile.MetaData","text":"<pre><code>Profile.MetaData [table] (Read-only) -- Data about the profile itself\n\nProfile.MetaData.ProfileCreateTime [number] (Read-only)\n-- os.time() timestamp of profile creation\n\nProfile.MetaData.SessionLoadCount [number] (Read-only)\n-- Amount of times the profile was loaded\n\nProfile.MetaData.ActiveSession [table] or nil (Read-only)\n-- {place_id, game_job_id} or nil\n-- Set to a session link if a Roblox server is currently the\n--   owner of this profile; nil if released\n\nProfile.MetaData.MetaTags [table] (Writable)\n-- {[\"tag_name\"] = tag_value, ...}\n-- Saved and auto-saved just like Profile.Data\n\nProfile.MetaData.MetaTagsLatest [table] (Read-only)\n-- the most recent version of MetaData.MetaTags which has\n--   been saved to the DataStore during the last auto-save\n--   or Profile:Save() call\n</code></pre> <p><code>Profile.MetaData</code> is a table containing data about the profile itself. <code>Profile.MetaData.MetaTags</code> is saved on the same DataStore key together with <code>Profile.Data</code>.</p>"},{"location":"api/#profilemetatagsupdated","title":"Profile.MetaTagsUpdated","text":"<pre><code>Profile.MetaTagsUpdated [ScriptSignal] (meta_tags_latest)\n</code></pre> <p>This signal fires after every auto-save, after <code>Profile.MetaData.MetaTagsLatest</code> has been updated with the version that's guaranteed to be saved. <code>MetaTagsUpdated</code> will fire regardless of whether <code>MetaTagsLatest</code> changed after update.</p> <p><code>MetaTagsUpdated</code> will also fire after the Profile is saved for the last time and released. Remember that changes to <code>Profile.Data</code> will not be saved after release - <code>Profile:IsActive()</code> will return <code>false</code> if the profile is released.</p> <p><code>MetaTagsUpdated</code> example use can be found in the Developer Products example code.</p>"},{"location":"api/#profilerobloxmetadata","title":"Profile.RobloxMetaData","text":"<pre><code>Profile.RobloxMetaData [table]\n-- Non-strict reference - developer can set this value to a new table reference\n</code></pre> <p>Be cautious of very harsh limits for maximum Roblox Metadata size - As of writing this, total table content size cannot exceed 300 characters.</p> <p>Table that gets saved as Metadata (Official documentation) of a DataStore key belonging to the profile. The way this table is saved is equivalent to using <code>DataStoreSetOptions:SetMetaData(Profile.RobloxMetaData)</code> and passing the <code>DataStoreSetOptions</code> object to a <code>:SetAsync()</code> call, except changes will truly get saved on the next auto-update cycle or when the profile is released. The periodic saving and saving upon releasing behaviour is identical to that of <code>Profile.Data</code> - After the profile is released further changes to this value will not be saved.</p> <p>Example:</p> <pre><code>local profile -- A profile object you loaded\n\n-- Mimicking the Roblox hub example:\nprofile.RobloxMetaData = {[\"ExperienceElement\"] = \"Fire\"}\n\n-- You can read from it and write to it at will:\nprint(profile.RobloxMetaData.ExperienceElement)\nprofile.RobloxMetaData.ExperienceElement = nil\nprofile.RobloxMetaData.UserCategory = \"Casual\"\n\n-- I think setting it to a whole table at profile load would\n--   be more safe considering the size limit for meta data\n--   is pretty tight:\nprofile.RobloxMetaData = {\n  UserCategory = \"Casual\",\n  FavoriteColor = {1, 0, 0},\n}\n</code></pre>"},{"location":"api/#profileuserids","title":"Profile.UserIds","text":"<p><pre><code>Profile.UserIds [table] -- (READ-ONLY) -- {user_id [number], ...}\n</code></pre> User ids associated with this profile. Entries must be added with Profile:AddUserId() and removed with Profile:RemoveUserId().</p>"},{"location":"api/#profilekeyinfo","title":"Profile.KeyInfo","text":"<p><pre><code>Profile.KeyInfo [DataStoreKeyInfo]\n</code></pre> The DataStoreKeyInfo (Official documentation) instance related to this profile</p>"},{"location":"api/#profilekeyinfoupdated","title":"Profile.KeyInfoUpdated","text":"<p><pre><code>Profile.KeyInfoUpdated [ScriptSignal] (key_info [DataStoreKeyInfo])\n</code></pre> A signal that gets triggered every time <code>Profile.KeyInfo</code> is updated with a new DataStoreKeyInfo instance reference after every auto-save or profile release.</p>"},{"location":"api/#profileglobalupdates","title":"Profile.GlobalUpdates","text":"<pre><code>Profile.GlobalUpdates [GlobalUpdates]\n</code></pre> <p>This is the <code>GlobalUpdates</code> object tied to this specific <code>Profile</code>. It exposes <code>GlobalUpdates</code> methods for update processing. (See Global Updates for more info)</p>"},{"location":"api/#profileisactive","title":"Profile:IsActive()","text":"<p><pre><code>Profile:IsActive() --&gt; [bool]\n</code></pre> Returns <code>true</code> while the profile is session-locked and saving of changes to <code>Profile.Data</code> is guaranteed.</p>"},{"location":"api/#profilegetmetatag","title":"Profile:GetMetaTag()","text":"<p><pre><code>Profile:GetMetaTag(tag_name) --&gt; value\n-- tag_name   [string]\n</code></pre> Equivalent of <code>Profile.MetaData.MetaTags[tag_name]</code>. See Profile:SetMetaTag() for more info.</p>"},{"location":"api/#profilereconcile","title":"Profile:Reconcile()","text":"<p><pre><code>Profile:Reconcile() --&gt; nil\n</code></pre> Fills in missing variables inside <code>Profile.Data</code> from <code>profile_template</code> table that was provided when calling <code>ProfileService.GetProfileStore()</code>. It's often necessary to use <code>:Reconcile()</code> if you're applying changes to your <code>profile_template</code> over the course of your game's development after release.</p> <p>The right time to call this method can be seen in the basic usage example.</p> <p>The following function is used in the reconciliation process: <pre><code>local function ReconcileTable(target, template)\n    for k, v in pairs(template) do\n        if type(k) == \"string\" then -- Only string keys will be reconciled\n            if target[k] == nil then\n                if type(v) == \"table\" then\n                    target[k] = DeepCopyTable(v)\n                else\n                    target[k] = v\n                end\n            elseif type(target[k]) == \"table\" and type(v) == \"table\" then\n                ReconcileTable(target[k], v)\n            end\n        end\n    end\nend\n</code></pre></p>"},{"location":"api/#profilelistentorelease","title":"Profile:ListenToRelease()","text":"<p><pre><code>Profile:ListenToRelease(listener) --&gt; [ScriptConnection] (place_id / nil, game_job_id / nil)\n-- listener   [function] (place_id / nil, game_job_id / nil)\n</code></pre> Listener functions subscribed to <code>Profile:ListenToRelease()</code> will be called when the profile is released remotely (Being <code>\"ForceLoad\"</code>'ed on a remote server) or locally (<code>Profile:Release()</code>). In common practice, the profile will rarely be released before the player leaves the game so it's recommended to simply :Kick() the Player when this happens.</p> <p>Warning</p> <p>After <code>Profile:ListenToRelease()</code> is triggered, it is too late to change <code>Profile.Data</code> for the final time. As long as the profile is active (<code>Profile:IsActive()</code> == <code>true</code>), you should store all profile related data immediately after it becomes available. An item trading operation between two profiles must happen without any yielding after it is confirmed that both profiles are active.</p>"},{"location":"api/#profilerelease","title":"Profile:Release()","text":"<p><pre><code>Profile:Release()\n</code></pre> Removes the session lock for this profile for this Roblox server. Call this method after you're done working with the <code>Profile</code> object. Profile data will be immediately saved for the last time.</p>"},{"location":"api/#profilelistentohopready","title":"Profile:ListenToHopReady()","text":"<p><pre><code>Profile:ListenToHopReady(listener) --&gt; [ScriptConnection] ()\n-- listener   [function] ()\n</code></pre> In many cases ProfileService will be fast enough when loading and releasing profiles as the player teleports between places belonging to the same universe / game. However, if you're experiencing noticable delays when loading profiles after a universe teleport, you should try implementing <code>:ListenToHopReady()</code>.</p> <p>A listener passed to <code>:ListenToHopReady()</code> will be executed after the releasing UpdateAsync call finishes. <code>:ListenToHopReady()</code> will usually call the listener in around a second, but may ocassionally take up to 7 seconds when a profile is released next to an auto-update interval (regular usage scenario - rapid loading / releasing of the same profile key may yield different results).</p> <p>Example use: <pre><code>local TeleportService = game:GetService(\"TeleportService\")\nlocal profile, player, place_id\n\nprofile:Release()\nprofile:ListenToHopReady(function()\n  TeleportService:TeleportAsync(place_id, {player})\nend)\n</code></pre></p> <p>In short, <code>Profile:ListenToRelease()</code> and <code>Profile:ListenToHopReady()</code> will both execute the listener function after release, but <code>Profile:ListenToHopReady()</code> will additionally wait until the session lock is removed from the <code>Profile</code>.</p>"},{"location":"api/#profileadduserid","title":"Profile:AddUserId()","text":"<p><pre><code>Profile:AddUserId(user_id)\n-- user_id   [number]\n</code></pre> Associates a <code>UserId</code> with the profile. Multiple users can be associated with a single profile by calling this method for each individual <code>UserId</code>. The primary use of this method is to comply with GDPR (The right to erasure). More information in official documentation.</p> <p>The right time to call this method can be seen in the basic usage example.</p>"},{"location":"api/#profileremoveuserid","title":"Profile:RemoveUserId()","text":"<p><pre><code>Profile:RemoveUserId(user_id)\n-- user_id   [number]\n</code></pre> Unassociates <code>UserId</code> with the profile if it was initially associated.</p>"},{"location":"api/#profileidentify","title":"Profile:Identify()","text":"<pre><code>Profile:Identify() --&gt; [string]\n-- Example return: \"[Store:\"GameData\";Scope:\"Live\";Key:\"Player_2312310\"]\"\n</code></pre> <p>Returns a string containing DataStore name, scope and key; Used for debugging;</p>"},{"location":"api/#profilesetmetatag","title":"Profile:SetMetaTag()","text":"<p><pre><code>Profile:SetMetaTag(tag_name, value)\n-- tag_name   [string]\n-- value      -- Any value supported by DataStore\n</code></pre> Equivalent of <code>Profile.MetaData.MetaTags[tag_name] = value</code>. Use for tagging your profile with information about itself such as:</p> <ul> <li><code>profile:SetMetaTag(\"DataVersion\", 1)</code> to let your game code know whether <code>Profile.Data</code> needs to be converted after massive changes to the game.</li> <li>Anything set through <code>profile:SetMetaTag(tag_name, value)</code> will be available through <code>Profile.MetaData.MetaTagsLatest[tag_name]</code> after an auto-save or a <code>:Save()</code> call - <code>Profile.MetaData.MetaTagsLatest</code> is a version of <code>Profile.MetaData.MetaTags</code> that has been successfully saved to the DataStore.</li> </ul> <p>Notice</p> <p>You can use <code>Profile.MetaData.MetaTagsLatest</code> for product purchase confirmation (By storing <code>receiptInfo.PurchaseId</code> values inside <code>Profile.MetaData.MetaTags</code> and waiting for them to appear in <code>Profile.MetaData.MetaTagsLatest</code>). Don't forget to clear really old <code>PurchaseId</code>'s to stay under DataStore limits.</p>"},{"location":"api/#profilesave","title":"Profile:Save()","text":"<p><pre><code>Profile:Save() -- Call to quickly progress GlobalUpdates\n--   state or to speed up save validation processes\n--   (Does not yield)\n</code></pre> Call <code>Profile:Save()</code> to quickly progress <code>GlobalUpdates</code> state or to speed up the propagation of <code>Profile.MetaData.MetaTags</code> changes to <code>Profile.MetaData.MetaTagsLatest</code>.</p> <p><code>Profile:Save()</code> should not be called for saving <code>Profile.Data</code> or <code>Profile.MetaData.MetaTags</code> - this is already done for you automatically.</p> <p>Warning</p> <p>Calling <code>Profile:Save()</code> when the <code>Profile</code> is released will throw an error. You can check <code>Profile:IsActive()</code> before using this method.</p>"},{"location":"api/#profileclearglobalupdates","title":"Profile:ClearGlobalUpdates()","text":"<pre><code>Profile:ClearGlobalUpdates()\n</code></pre> <p>Only works for profiles loaded through :ViewProfileAsync() or :ProfileVersionQuery()</p> <p>Clears all global update data (active or locked) for a profile payload. It may be desirable to clear potential \"residue\" global updates (e.g. pending gifts) which were existing in a snapshot which is being used to recover player data through :ProfileVersionQuery().</p>"},{"location":"api/#profileoverwriteasync","title":"Profile:OverwriteAsync()","text":"<pre><code>Profile:OverwriteAsync()\n</code></pre> <p>Only works for profiles loaded through :ViewProfileAsync() or :ProfileVersionQuery()</p> <p>Only use for rollback payloads (Setting latest version to a copy of a previous version)!</p> <p>Using this method for editing latest player data when the player is in-game can lead to several minutes of lost progress - it should be replaced by :LoadProfileAsync() which will wait for the next live profile auto-save if the player is in-game, allowing the remote server to release the profile and save latest data.</p> <p>Pushes the <code>Profile</code> payload to the DataStore (saves the profile) and releases the session lock for the profile.</p>"},{"location":"api/#global-updates","title":"Global Updates","text":"<p>Global updates is a powerful feature of ProfileService, used for sending information to a desired player profile across servers, within the server or to a player profile that is not currently active in any Roblox server (Kind of like MessagingService, but slower and doesn't require the recipient to be active). The primary intended use of global updates is to support sending gifts among players, or giving items to players through a custom admin tool. The benefit of using global updates is it's API simplicity (This is as simple as it gets, sorry \ud83d\ude02) and the fact that global updates are pulled from the DataStore whenever the profile is auto-saved at no additional expense of more DataStore calls!</p> <p>Global updates can be <code>Active</code>, <code>Locked</code> and <code>Cleared</code>:</p> <ul> <li>Whenever a global update is created, it will be <code>Active</code> by default</li> <li><code>Active</code> updates can be changed or cleared within a <code>:GlobalUpdateProfileAsync()</code> call</li> <li>Normally, when the profile is active on a Roblox server, you should always progress all <code>Active</code> updates to the <code>Locked</code> state</li> <li><code>Locked</code> updates can no longer be changed or cleared within a <code>:GlobalUpdateProfileAsync()</code> call</li> <li><code>Locked</code> updates are ready to be processed (e.g., add gift to player inventory) and imediately <code>Locked</code> by calling <code>:LockActiveUpdate(update_id)</code></li> <li><code>Cleared</code> updates will immediately disappear from the profile forever</li> </ul>"},{"location":"api/#always-available","title":"Always available","text":""},{"location":"api/#globalupdatesgetactiveupdates","title":"GlobalUpdates:GetActiveUpdates()","text":"<p><pre><code>GlobalUpdates:GetActiveUpdates() --&gt; [table] { {update_id, update_data}, ...}\n</code></pre> Should be used immediately after a <code>Profile</code> is loaded to scan and progress any pending <code>Active</code> updates to <code>Locked</code> state: <pre><code>for _, update in ipairs(profile.GlobalUpdates:GetActiveUpdates()) do\n  profile.GlobalUpdates:LockActiveUpdate(update[1])\nend\n</code></pre></p>"},{"location":"api/#globalupdatesgetlockedupdates","title":"GlobalUpdates:GetLockedUpdates()","text":"<p><pre><code>GlobalUpdates:GetLockedUpdates() --&gt; [table] { {update_id, update_data}, ...}\n</code></pre> Should be used immediately after a <code>Profile</code> is loaded to scan and progress any pending <code>Locked</code> updates to <code>Cleared</code> state: <pre><code>for _, update in ipairs(profile.GlobalUpdates:GetLockedUpdates()) do\n  local update_id = update[1]\n  local update_data = update[2]\n  if update_data.Type == \"AdminGift\" and update_data.Item == \"Coins\" then\n    profile.Data.Coins = profile.Data.Coins + update_data.Amount\n  end\n  profile.GlobalUpdates:ClearLockedUpdate(update_id)\nend\n</code></pre></p>"},{"location":"api/#only-when-accessed-from-profileglobalupdates","title":"Only when accessed from <code>Profile.GlobalUpdates</code>","text":""},{"location":"api/#globalupdateslistentonewactiveupdate","title":"GlobalUpdates:ListenToNewActiveUpdate()","text":"<p><pre><code>GlobalUpdates:ListenToNewActiveUpdate(listener) --&gt; [ScriptConnection]\n-- listener   [function](update_id, update_data)\n</code></pre> In most games, you should progress all <code>Active</code> updates to <code>Locked</code> state: <pre><code>profile.GlobalUpdates:ListenToNewActiveUpdate(function(update_id, update_data)\n  profile.GlobalUpdates:LockActiveUpdate(update_id)\nend)\n</code></pre></p>"},{"location":"api/#globalupdateslistentonewlockedupdate","title":"GlobalUpdates:ListenToNewLockedUpdate()","text":"<p><pre><code>GlobalUpdates:ListenToNewLockedUpdate(listener) --&gt; [ScriptConnection]\n-- listener   [function](update_id, update_data)\n-- Must always call GlobalUpdates:ClearLockedUpdate(update_id)\n--   after processing the locked update.\n</code></pre> When you get a <code>Locked</code> update via <code>GlobalUpdates:ListenToNewLockedUpdate()</code>, the update is ready to be proccessed and immediately locked: <pre><code>profile.GlobalUpdates:ListenToNewLockedUpdate(function(update_id, update_data)\n  if update_data.Type == \"AdminGift\" and update_data.Item == \"Coins\" then\n    profile.Data.Coins = profile.Data.Coins + update_data.Amount\n  end\n  profile.GlobalUpdates:ClearLockedUpdate(update_id)\nend)\n</code></pre></p>"},{"location":"api/#globalupdateslockactiveupdate","title":"GlobalUpdates:LockActiveUpdate()","text":"<p><pre><code>GlobalUpdates:LockActiveUpdate(update_id)\n-- update_id   [number] -- Id of an existing global update\n</code></pre> Turns an <code>Active</code> update into a <code>Locked</code> update. Will invoke <code>GlobalUpdates:ListenToNewLockedUpdate()</code> after an auto-save (less than 30 seconds) or <code>Profile:Save()</code>.</p> <p>Warning</p> <p>Calling <code>GlobalUpdates:LockActiveUpdate()</code> when the <code>Profile</code> is released will throw an error. You can check <code>Profile:IsActive()</code> before using this method. ProfileService guarantees that the <code>Profile</code> will be active when <code>GlobalUpdates:ListenToNewActiveUpdate()</code> listeners are triggered.</p>"},{"location":"api/#globalupdatesclearlockedupdate","title":"GlobalUpdates:ClearLockedUpdate()","text":"<p><pre><code>GlobalUpdates:ClearLockedUpdate(update_id)\n-- update_id   [number] -- Id of an existing global update\n</code></pre> Clears a <code>Locked</code> update completely from the profile.</p> <p>Warning</p> <p>Calling <code>GlobalUpdates:ClearLockedUpdate()</code> when the <code>Profile</code> is released will throw an error. You can check <code>Profile:IsActive()</code> before using this method. ProfileService guarantees that the <code>Profile</code> will be active when <code>GlobalUpdates:ListenToNewLockedUpdate()</code> listeners are triggered.</p>"},{"location":"api/#available-inside-update_handler-during-a-profilestoreglobalupdateprofileasync-call","title":"Available inside <code>update_handler</code> during a <code>ProfileStore:GlobalUpdateProfileAsync()</code> call","text":""},{"location":"api/#globalupdatesaddactiveupdate","title":"GlobalUpdates:AddActiveUpdate()","text":"<p><pre><code>GlobalUpdates:AddActiveUpdate(update_data)\n-- update_data   [table] -- Your custom global update data\n</code></pre> Used to send a new <code>Active</code> update to the profile.</p>"},{"location":"api/#globalupdateschangeactiveupdate","title":"GlobalUpdates:ChangeActiveUpdate()","text":"<p><pre><code>GlobalUpdates:ChangeActiveUpdate(update_id, update_data)\n-- update_id     [number] -- Id of an existing global update\n-- update_data   [table] -- New data that replaces previously set update_data\n</code></pre> Changing <code>Active</code> updates can be used for stacking player gifts, particularly when lots of players can be sending lots of gifts to a Youtube celebrity so the <code>Profile</code> would not exceed the DataStore data limit.</p>"},{"location":"api/#globalupdatesclearactiveupdate","title":"GlobalUpdates:ClearActiveUpdate()","text":"<p><pre><code>GlobalUpdates:ClearActiveUpdate(update_id)\n-- update_id   [number] -- Id of an existing global update\n</code></pre> Removes an <code>Active</code> update from the profile completely.</p>"},{"location":"troubleshooting/","title":"Troubleshooting","text":"<p>Whether you're still writing your game code or already ran into a problem while using ProfileService, this page is a valuable resource for avoiding several crucial mistakes.</p>"},{"location":"troubleshooting/#problems-in-roblox-studio-testing","title":"Problems in Roblox studio testing","text":"<p>By default, data saved with ProfileService in Roblox Studio will not persist. This can be changed by enabling studio access to API services.</p> <p>Warning</p> <p>When studio access to API services is enabled, ProfileService will write to live DataStore keys of the game you're editing (unless ProfileStore.Mock is used) and you might accidentally make unwanted changes to your game's saved data. For more info, check the official documentation.</p>"},{"location":"troubleshooting/#saving-data-which-roblox-cannot-serialize","title":"Saving data which Roblox cannot serialize","text":"<p>I've made the decision to opt-out <code>Profile.Data</code> and <code>Profile.MetaData.MetaTags</code> automatic checking for unserializable data types for efficiency reasons. Consequently, you must be aware of what you MUST AVOID writing inside <code>Profile.Data</code> or <code>Profile.MetaData.MetaTags</code>, directly and inside any nested tables:</p> <ul> <li><code>NaN</code> values - you can check if a number is <code>NaN</code> by comparing it with itself - <code>print(NaN == NaN) --&gt; false</code> (e.g., <code>Profile.Data = {Experience = 0/0}</code>). <code>NaN</code> values are a result of division by zero and edge cases of some math operations (<code>math.acos(2)</code> is <code>-NaN</code>).</li> <li>Table keys that are neither strings nor numbers (e.g., <code>Profile.Data[game.Workspace] = true</code>).</li> <li>Mixing string keys with number keys within the same table (e.g., <code>Profile.Data = {Coins = 100, [5] = \"yes\"}</code>).</li> <li>Storing tables with non-sequential indexes (e.g., <code>Profile.Data = {[1] = \"Apple\", [2] = \"Banana\", [3546] = \"Peanut\"}</code>). If you really have to store non-sequential numbers as indexes, you will have to turn those numbers into <code>string</code> indexes: <code>Profile.Data.Friends[tostring(user_id)] = {GoodFriend = true}</code>.</li> <li>Storing cyclic tables (e.g., <code>Profile.Data = {Self = Profile.Data}</code>).</li> <li>Storing any <code>userdata</code> including <code>Instance</code>, <code>Vector3</code>, <code>CFrame</code>, <code>Udim2</code>, etc. Check whether your value is a <code>userdata</code> by running <code>print(type(value) == \"userdata\")</code> (e.g., <code>Profile.Data = {LastPosition = Vector3.new(0, 0, 0)}</code>) - For storage, you will have to manually convert your <code>userdata</code> to tables, numbers and strings for storage (e.g., <code>Profile.Data = {LastPosition = {position.X, position.Y, position.Z} }</code>).</li> </ul> <p>This is a limitation of the DataStore API which ProfileService is based on.</p> <p>Warning</p> <p>Failure to prevent these data types may result in silent data loss, silent errors, fatal errors and overall failure to save data.</p>"},{"location":"troubleshooting/#profiles-take-over-7-seconds-to-load","title":"Profiles take over 7 seconds to load","text":"<p>Notice</p> <pre><code>Due to technical limitations, it's expected that at least 5% of the time, when the player hops servers rapidly, the profile\ncan take up to 7 seconds to load (Can be greatly improved by using [Profile:ListenToHopReady()](/ProfileService/api/#profilelistentohopready)).\nIf implemented correctly, ProfileService will load profiles as fast as the Roblox API allows\nit when the player joins a server without a server hop. It's recommended to release profiles right before universe teleports\nto speed up session lock releasing and further preventing time penalties related to server hopping as much as possible.\nIf your profiles load slower than 7 seconds on a constant basis, continue reading this topic.\n</code></pre> <p>MAKE SURE YOUR ProfileService MODULE IS UP TO DATE</p> <p>Just to be clear, ProfileService is not a module that trades in speed for security - if implemented properly, your profiles must usually load within 1 to 2 seconds - that's how long a single DataStore UpdateAsync call will take.</p> <p>The problem</p> <p>More often than not, ProfileStore:LoadProfileAsync() is taking a clearly longer than usual amount of time to load, usually 7 seconds or much more.</p> <pre><code>local start_time = tick()\nProfileStore:LoadProfileAsync(profile_key)\nprint(tick() - start_time) --&gt; A value over 10 seconds\n</code></pre> <p>The culprit</p> <ul> <li>Is your code really releasing your profiles after it's done working with them?</li> <li>Are you releasing your profiles immediately after the player leaves the game?</li> <li>If teleporting between places in your game (universe), are you using Profile:ListenToHopReady()?</li> </ul> <p>Functions connected to Players.PlayerRemoving can be tricky to notice errors for because, when testing alone, you will be leaving the game before the errors appear on the developer console.</p> <p>If a player hops to another server (Server 2) before the previous one (Server 1) releases (removes session-lock from) the player's <code>Profile</code>, Server 2 will wait until Server 1 releases the <code>Profile</code>. ProfileService checks the session-lock state of profiles every 7 seconds during a ProfileStore:LoadProfileAsync() call and this will immediately slow down <code>Profile</code> loading very noticably. This is what we would call a race condition.</p> <p>Mistake example #1: <pre><code>Players.PlayerRemoving:Connect(function(player)\n    local profile = Profiles[player]\n    if profile ~= nil then\n        progile:Release() -- \"progile\" IS A TYPO!\n    end\nend)\n</code></pre> This example would throw an error, though you would need to be inside the server while another player triggers the <code>.PlayerRemoving</code> event.</p> <p>Mistake example #2: <pre><code>Players.PlayerRemoving:Connect(function(player)\n    local profile = Profiles[player]\n    if profile ~= nil then\n        SaveData(profile) -- Are you sure this function doesn't error?\n        profile:Release()\n    end\nend)\n</code></pre> When you're pretty sure you didn't make any typos, the next thing you should check is that nothing can error inside the function connected to <code>.PlayerRemoving</code>.  </p> <p>Disclaimer: I don't advise modifying <code>Profile.Data</code> after the player leaves - it's a bad practice in securing your data. You should always store data in a way where unexpectedly losing access to writing to <code>Profile.Data</code> (e.g. server crash) would not cause massive data loss.</p> <p>Mistake example #3: <pre><code>Players.PlayerRemoving:Connect(function(player)\n    local profile = Profiles[player]\n    if profile ~= nil then\n        wait(1) -- Or any function with \"Wait\", \"Async\" or \"Yield\" in its name\n        profile:Release()\n    end\nend)\n</code></pre> You should immediately release your profiles after the player leaves (<code>wait(1)</code> is bad in this example), otherwise you risk creating a race condition where another server that the player joined is trying to load a <code>Profile</code> that hasn't been released yet.</p> <p>Mistake example #4: <pre><code>local profile_key, update_handler\n\n-- This simulates excessive UpdateAsync calls for the same Profile key:\nfor i = 1, 6 do\n    ProfileStore:GlobalUpdateProfileAsync(profile_key, update_handler)\nend\n</code></pre> Excessive use of ProfileStore:GlobalUpdateProfileAsync() can lead to dead session locks and event lost <code>Profile.Data</code> (latter is mostly possible only if the <code>Profile</code> is loaded in the same session as <code>:GlobalUpdateProfileAsync()</code> is called). This is due to a queue system that executes every write request for the <code>Profile</code> every 7 seconds - if this queue grows larger than the BindToClose timeout (approx. 30 seconds), some requests in the queue can be lost after the game shuts down.</p> <p>How to be sure my profiles are being released? </p> <p>Add a <code>print()</code>: <pre><code>Players.PlayerRemoving:Connect(function(player)\n    local profile = Profiles[player]\n    if profile ~= nil then\n        profile:Release()\n        print(player.Name .. \"'s profile has been released!\")\n    end\nend)\n</code></pre> If you're having long <code>Profile</code> loading issues, this is the first thing you should do. Check the developer console for the print and any other possible errors.</p> <p>When ProfileStore:LoadProfileAsync() finishes loading in...</p> <ul> <li>less than 2 seconds - You're good!</li> <li>7 to 30 seconds - Most likely a player server hop race condition (Mistake example #3)</li> <li>Over 60 seconds - The previous server is not releasing the profile / Dead session lock (Mistake examples #1, #2 and #4)</li> </ul>"},{"location":"troubleshooting/#datastore-warnings-caused-by-profileservice","title":"DataStore warnings caused by ProfileService","text":"<p>\"DataStore request was added to queue. If request queue fills, further requests will be dropped. Try sending fewer requests. Key = XXXXXX\"</p> <p>Is this really bad?</p> <p>If you're only getting one or two warnings every couple of minutes or so, most likely not. Since March 2021 the ProfileService module now uses a custom queue system which greatly reduces Roblox API queue warnings.</p> <p>What does this warning mean?</p> <p>As of writing this guide (July 2020), based on a DevForum thread, Rapid successive UpdateAsync calls will be throttled by the DataStoreService and added to a queue:</p> <p>Throttling queues</p> <p>Every actual budget type (GetAsync, SetIncrementAsync, GetSortedAsync, OnUpdateAsync, SetIncrementSortedAsync) has its own throttling queue. Each of these five throttling queues has a queue size of 30 throttled requests max. Throttled requests are added to the queue of the corresponding budget type that it consumes.</p> <p>When will you get warnings</p> <p>Queue warnings can no longer be caused by faulty use of ProfileService as of March 2021 (Go update now you bastard). I expect these warnings to sometimes pop up during game startup or huge lag spikes / mild API outages.</p>"},{"location":"tutorial/basic_usage/","title":"Basic Usage","text":"<p>Most of the work with ProfileService is setting up your data loading code. Afterwards, data is read and written directly to the <code>Profile.Data</code> table without the necessity to use any ProfileService method calls - you set up your own read / write functions, wrappers, classes with profiles as components, etc!</p> <p>The code below is a basic profile loader implementation for ProfileService:</p> <p>Note</p> <p>Unlike most custom DataStore modules where you would listen for <code>Players.PlayerRemoving</code> to clean up, ProfileService may release (destroy) the profile before the player leaves the server - this has to be handled by using <code>Profile:ListenToRelease(listener_function)</code> - any amount of functions can be added!</p> <pre><code>-- ProfileTemplate table is what empty profiles will default to.\n-- Updating the template will not include missing template values\n--   in existing player profiles!\nlocal ProfileTemplate = {\n    Cash = 0,\n    Items = {},\n    LogInTimes = 0,\n}\n\n----- Loaded Modules -----\n\nlocal ProfileService = require(game.ServerScriptService.ProfileService)\n\n----- Private Variables -----\n\nlocal Players = game:GetService(\"Players\")\n\nlocal ProfileStore = ProfileService.GetProfileStore(\n    \"PlayerData\",\n    ProfileTemplate\n)\n\nlocal Profiles = {} -- [player] = profile\n\n----- Private Functions -----\n\nlocal function GiveCash(profile, amount)\n    -- If \"Cash\" was not defined in the ProfileTemplate at game launch,\n    --   you will have to perform the following:\n    if profile.Data.Cash == nil then\n        profile.Data.Cash = 0\n    end\n    -- Increment the \"Cash\" value:\n    profile.Data.Cash = profile.Data.Cash + amount\nend\n\nlocal function DoSomethingWithALoadedProfile(player, profile)\n    profile.Data.LogInTimes = profile.Data.LogInTimes + 1\n    print(player.Name .. \" has logged in \" .. tostring(profile.Data.LogInTimes)\n        .. \" time\" .. ((profile.Data.LogInTimes &gt; 1) and \"s\" or \"\"))\n    GiveCash(profile, 100)\n    print(player.Name .. \" owns \" .. tostring(profile.Data.Cash) .. \" now!\")\nend\n\nlocal function PlayerAdded(player)\n    local profile = ProfileStore:LoadProfileAsync(\"Player_\" .. player.UserId)\n    if profile ~= nil then\n        profile:AddUserId(player.UserId) -- GDPR compliance\n        profile:Reconcile() -- Fill in missing variables from ProfileTemplate (optional)\n        profile:ListenToRelease(function()\n            Profiles[player] = nil\n            -- The profile could've been loaded on another Roblox server:\n            player:Kick()\n        end)\n        if player:IsDescendantOf(Players) == true then\n            Profiles[player] = profile\n            -- A profile has been successfully loaded:\n            DoSomethingWithALoadedProfile(player, profile)\n        else\n            -- Player left before the profile loaded:\n            profile:Release()\n        end\n    else\n        -- The profile couldn't be loaded possibly due to other\n        --   Roblox servers trying to load this profile at the same time:\n        player:Kick() \n    end\nend\n\n----- Initialize -----\n\n-- In case Players have joined the server earlier than this script ran:\nfor _, player in ipairs(Players:GetPlayers()) do\n    task.spawn(PlayerAdded, player)\nend\n\n----- Connections -----\n\nPlayers.PlayerAdded:Connect(PlayerAdded)\n\nPlayers.PlayerRemoving:Connect(function(player)\n    local profile = Profiles[player]\n    if profile ~= nil then\n        profile:Release()\n    end\nend)\n</code></pre>"},{"location":"tutorial/developer_products/","title":"Developer Products","text":"<p>The following example features code that would reliably handle developer product purchases through the ProcessReceipt callback. We yield the <code>ProcessReceipt</code> callback until we know that the purchase was successfully saved to the DataStore or until the player leaves and triggers a profile release.</p> <pre><code>local SETTINGS = {\n\n    ProfileTemplate = {\n        Cash = 0,\n    },\n\n    Products = { -- developer_product_id = function(profile)\n        [97662780] = function(profile)\n            profile.Data.Cash += 100\n        end,\n        [97663121] = function(profile)\n            profile.Data.Cash += 1000\n        end,\n    },\n\n    PurchaseIdLog = 50, -- Store this amount of purchase id's in MetaTags;\n        -- This value must be reasonably big enough so the player would not be able\n        -- to purchase products faster than individual purchases can be confirmed.\n        -- Anything beyond 30 should be good enough.\n\n}\n\n----- Loaded Modules -----\n\nlocal ProfileService = require(game.ServerScriptService.ProfileService)\n\n----- Private Variables -----\n\nlocal Players = game:GetService(\"Players\")\nlocal MarketplaceService = game:GetService(\"MarketplaceService\")\n\nlocal GameProfileStore = ProfileService.GetProfileStore(\n    \"PlayerData\",\n    SETTINGS.ProfileTemplate\n)\n\nlocal Profiles = {} -- {player = profile, ...}\n\n----- Private Functions -----\n\nlocal function PlayerAdded(player)\n    local profile = GameProfileStore:LoadProfileAsync(\"Player_\" .. player.UserId)\n    if profile ~= nil then\n        profile:AddUserId(player.UserId) -- GDPR compliance\n        profile:Reconcile() -- Fill in missing variables from ProfileTemplate (optional)\n        profile:ListenToRelease(function()\n            Profiles[player] = nil\n            player:Kick() -- The profile could've been loaded on another Roblox server\n        end)\n        if player:IsDescendantOf(Players) == true then\n            Profiles[player] = profile\n        else\n            profile:Release() -- Player left before the profile loaded\n        end\n    else\n        -- The profile couldn't be loaded possibly due to other\n        --   Roblox servers trying to load this profile at the same time:\n        player:Kick() \n    end\nend\n\nfunction PurchaseIdCheckAsync(profile, purchase_id, grant_product_callback) --&gt; Enum.ProductPurchaseDecision\n    -- Yields until the purchase_id is confirmed to be saved to the profile or the profile is released\n\n    if profile:IsActive() ~= true then\n\n        return Enum.ProductPurchaseDecision.NotProcessedYet\n\n    else\n\n        local meta_data = profile.MetaData\n\n        local local_purchase_ids = meta_data.MetaTags.ProfilePurchaseIds\n        if local_purchase_ids == nil then\n            local_purchase_ids = {}\n            meta_data.MetaTags.ProfilePurchaseIds = local_purchase_ids\n        end\n\n        -- Granting product if not received:\n\n        if table.find(local_purchase_ids, purchase_id) == nil then\n            while #local_purchase_ids &gt;= SETTINGS.PurchaseIdLog do\n                table.remove(local_purchase_ids, 1)\n            end\n            table.insert(local_purchase_ids, purchase_id)\n            task.spawn(grant_product_callback)\n        end\n\n        -- Waiting until the purchase is confirmed to be saved:\n\n        local result = nil\n\n        local function check_latest_meta_tags()\n            local saved_purchase_ids = meta_data.MetaTagsLatest.ProfilePurchaseIds\n            if saved_purchase_ids ~= nil and table.find(saved_purchase_ids, purchase_id) ~= nil then\n                result = Enum.ProductPurchaseDecision.PurchaseGranted\n            end\n        end\n\n        check_latest_meta_tags()\n\n        local meta_tags_connection = profile.MetaTagsUpdated:Connect(function()\n            check_latest_meta_tags()\n            -- When MetaTagsUpdated fires after profile release:\n            if profile:IsActive() == false and result == nil then\n                result = Enum.ProductPurchaseDecision.NotProcessedYet\n            end\n        end)\n\n        while result == nil do\n            task.wait()\n        end\n\n        meta_tags_connection:Disconnect()\n\n        return result\n\n    end\n\nend\n\nlocal function GetPlayerProfileAsync(player) --&gt; [Profile] / nil\n    -- Yields until a Profile linked to a player is loaded or the player leaves\n    local profile = Profiles[player]\n    while profile == nil and player:IsDescendantOf(Players) == true do\n        task.wait()\n        profile = Profiles[player]\n    end\n    return profile\nend\n\nlocal function GrantProduct(player, product_id)\n    -- We shouldn't yield during the product granting process!\n    local profile = Profiles[player]\n    local product_function = SETTINGS.Products[product_id]\n    if product_function ~= nil then\n        product_function(profile)\n    else\n        warn(\"ProductId \" .. tostring(product_id) .. \" has not been defined in Products table\")\n    end\nend\n\nlocal function ProcessReceipt(receipt_info)\n\n    local player = Players:GetPlayerByUserId(receipt_info.PlayerId)\n\n    if player == nil then\n        return Enum.ProductPurchaseDecision.NotProcessedYet\n    end\n\n    local profile = GetPlayerProfileAsync(player)\n\n    if profile ~= nil then\n\n        return PurchaseIdCheckAsync(\n            profile,\n            receipt_info.PurchaseId,\n            function()\n                GrantProduct(player, receipt_info.ProductId)\n            end\n        )\n\n    else\n        return Enum.ProductPurchaseDecision.NotProcessedYet\n    end\n\nend\n\n----- Initialize -----\n\nfor _, player in ipairs(Players:GetPlayers()) do\n    task.spawn(PlayerAdded, player)\nend\n\nMarketplaceService.ProcessReceipt = ProcessReceipt\n\n----- Connections -----\n\nPlayers.PlayerAdded:Connect(PlayerAdded)\n\nPlayers.PlayerRemoving:Connect(function(player)\n    local profile = Profiles[player]\n    if profile ~= nil then\n        profile:Release()\n    end\nend)\n</code></pre>"},{"location":"tutorial/settingup/","title":"Setting up","text":"<p>ProfileService is supposed to be a ModuleScript which you can place inside your Roblox game's ServerScriptService or wherever else is preferred. ProfileService can only be used server-side</p>"},{"location":"tutorial/settingup/#option-1-get-profileservice-from-the-roblox-library","title":"Option #1: Get ProfileService from the Roblox library","text":"<ul> <li>Get the library model here</li> <li>Move \"ProfileService\" ModuleScript to ServerScriptService:</li> </ul>"},{"location":"tutorial/settingup/#option-2-github","title":"Option #2: Github","text":"<ul> <li>ProfileService repository</li> </ul>"}]}